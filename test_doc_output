=========================================
Documentation of the anyblok_test project
=========================================

Bloks
=====

anyblok-core
------------

This Blok is required in all AnyBlok applications.

    This Blok provides the main fonctionalities for Bloks management (install,
    update, uninstall…).

    It also brings the representation of Anyblok objects (Models, Fields, etc.)
    within the database itself, and some fundamental facilities.

    * Core Models

      These are pure code Models, used as base classes:

      - Base: inherited by all Models
      - SqlBase: inherited by all models backed by an SQL table
      - SqlViewBase: inherited by all models bacled by an SQL view

    * System Models

      These correspond to actual tables in the table. They provide reflection
      or fundamental facilities.

      - Blok: represent all *available* Bloks, with their state and more
      - Model
      - Field
      - Column
      - Relationship
      - :class:`Sequence <.system.sequence.Sequence>`: database sequences,
        for use in applications.
      - :class:`Parameter <.system.parameter.Parameter>`: application
        parameters
    

Parameter:

* **author** = Suzanne Jean-Sébastien
* **version** = 1.4.0
* **installed_version** = 1.4.0



Models
======

This the differents models defined on the project

Model.System
------------

Properties:

* **table name** : No table

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

Model.System.Model
------------------

Models assembled

Properties:

* **table name** : system_model

Fields
~~~~~~

* name

 **code** (system_model.name),  **model** (Model.System.Model),  **label** (Name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* table

 **code** (system_model.table),  **model** (Model.System.Model),  **label** (Table),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* schema

 **code** (system_model.schema),  **model** (Model.System.Model),  **label** (Schema),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* is_sql_model

 **code** (system_model.is_sql_model),  **model** (Model.System.Model),  **label** (Is a SQL model),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* description

 **code** (system_model.description),  **model** (Model.System.Model),  **label** (Description),  **ftype** (Function),  **entity_type** (Model.System.Field)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_fields

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* description

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* getFieldType

* get_all_registry_names

* get_field

* get_field_model

* get_hybrid_property_columns

* get_model_doc_string

 Return the docstring of the model
        

* get_modified_fields

return the fields which have changed and their previous values

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* is_sql_model

* listener_update_model

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* name

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* schema

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* table

* update_fields

* update_list

 Insert and update the table of models

        :exception: Exception
        

* update_sql_statement

Model.System.Field
------------------

Properties:

* **table name** : system_field

Fields
~~~~~~

* name

 **code** (system_field.name),  **model** (Model.System.Field),  **label** (Name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* code

 **code** (system_field.code),  **model** (Model.System.Field),  **label** (Code),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* model

 **code** (system_field.model),  **model** (Model.System.Field),  **label** (Model),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* label

 **code** (system_field.label),  **model** (Model.System.Field),  **label** (Label),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* ftype

 **code** (system_field.ftype),  **model** (Model.System.Field),  **label** (Type),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* entity_type

 **code** (system_field.entity_type),  **model** (Model.System.Field),  **label** (Entity type),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _description

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_field

 Insert a field definition

        :param rname: name of the field
        :param label: label of the field
        :param model: namespace of the model
        :param table: name of the table of the model
        :param ftype: type of the AnyBlok Field
        

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* alter_field

 Update an existing field

        :param field: instance of the Field model to update
        :param label: label of the field
        :param ftype: type of the AnyBlok Field
        

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* code

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* entity_type

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* ftype

* getFieldType

* get_all_registry_names

* get_cname

* get_hybrid_property_columns

* get_modified_fields

return the fields which have changed and their previous values

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* label

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* model

* name

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* update_sql_statement

Model.System.Column
-------------------

Properties:

* **table name** : system_column

Fields
~~~~~~

* name

 **code** (system_column.name),  **model** (Model.System.Column),  **label** (Name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* model

 **code** (system_column.model),  **model** (Model.System.Column),  **label** (Model),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* autoincrement

 **code** (system_column.autoincrement),  **model** (Model.System.Column),  **label** (Auto increment),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* foreign_key

 **code** (system_column.foreign_key),  **model** (Model.System.Column),  **label** (Foreign key),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* primary_key

 **code** (system_column.primary_key),  **model** (Model.System.Column),  **label** (Primary key),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* unique

 **code** (system_column.unique),  **model** (Model.System.Column),  **label** (Unique),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* nullable

 **code** (system_column.nullable),  **model** (Model.System.Column),  **label** (Nullable),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* remote_model

 **code** (system_column.remote_model),  **model** (Model.System.Column),  **label** (Remote model),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _description

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_field

 Insert a column definition

        :param cname: name of the column
        :param column: instance of the column
        :param model: namespace of the model
        :param table: name of the table of the model
        :param ftype: type of the AnyBlok Field
        

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* alter_field

 Update an existing column

        :param column: instance of the Column model to update
        :param meta_column: instance of the SqlAlchemy column
        :param ftype: type of the AnyBlok Field
        

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* autoincrement

* code

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* entity_type

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* foreign_key

* ftype

* getFieldType

* get_all_registry_names

* get_cname

 Return the real name of the column

        :param field: the instance of the column
        :param cname: Not use here
        :rtype: string of the real column name
        

* get_hybrid_property_columns

* get_modified_fields

return the fields which have changed and their previous values

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* label

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* model

* name

* nullable

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* primary_key

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* remote_model

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* unique

* update_sql_statement

* use

Model.System.RelationShip
-------------------------

Properties:

* **table name** : system_relationship

Fields
~~~~~~

* name

 **code** (system_relationship.name),  **model** (Model.System.RelationShip),  **label** (Name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* model

 **code** (system_relationship.model),  **model** (Model.System.RelationShip),  **label** (Model),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* local_columns

 **code** (system_relationship.local_columns),  **model** (Model.System.RelationShip),  **label** (Local columns),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* remote_columns

 **code** (system_relationship.remote_columns),  **model** (Model.System.RelationShip),  **label** (Remote columns),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* remote_name

 **code** (system_relationship.remote_name),  **model** (Model.System.RelationShip),  **label** (Remote name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* remote_model

 **code** (system_relationship.remote_model),  **model** (Model.System.RelationShip),  **label** (Remote model),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* remote

 **code** (system_relationship.remote),  **model** (Model.System.RelationShip),  **label** (Remote),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* nullable

 **code** (system_relationship.nullable),  **model** (Model.System.RelationShip),  **label** (Nullable),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _description

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_field

 Insert a relationship definition

        :param rname: name of the relationship
        :param relation: instance of the relationship
        :param model: namespace of the model
        :param table: name of the table of the model
        :param ftype: type of the AnyBlok Field
        

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* alter_field

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* code

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* entity_type

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* ftype

* getFieldType

* get_all_registry_names

* get_cname

* get_hybrid_property_columns

* get_modified_fields

return the fields which have changed and their previous values

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* label

* local_columns

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* model

* name

* nullable

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* remote

* remote_columns

* remote_model

* remote_name

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* update_sql_statement

* use

Model.System.Blok
-----------------

Properties:

* **table name** : system_blok

Fields
~~~~~~

* name

 **code** (system_blok.name),  **model** (Model.System.Blok),  **label** (Name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* state

 **code** (system_blok.state),  **model** (Model.System.Blok),  **label** (State),  **ftype** (Selection),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* author

 **code** (system_blok.author),  **model** (Model.System.Blok),  **label** (Author),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* order

 **code** (system_blok.order),  **model** (Model.System.Blok),  **label** (Order),  **ftype** (Integer),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* short_description

 **code** (system_blok.short_description),  **model** (Model.System.Blok),  **label** (Short description),  **ftype** (Function),  **entity_type** (Model.System.Field)

* long_description

 **code** (system_blok.long_description),  **model** (Model.System.Blok),  **label** (Long description),  **ftype** (Function),  **entity_type** (Model.System.Field)

* logo

 **code** (system_blok.logo),  **model** (Model.System.Blok),  **label** (Logo),  **ftype** (Function),  **entity_type** (Model.System.Field)

* version

 **code** (system_blok.version),  **model** (Model.System.Blok),  **label** (Version),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* installed_version

 **code** (system_blok.installed_version),  **model** (Model.System.Blok),  **label** (Installed version),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* STATES

dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* apply_state

 Call the rigth method is the blok state change

        .. warning::

            for the uninstallation the method called is ``uninstall_all``

        :param bloks: list of the blok name load by the registry
        

* author

* check_if_the_conditional_are_installed

 Return True if all the conditions to install the blok are satisfied

        :param blok: blok name
        :rtype: boolean
        

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* getFieldType

* get_all_registry_names

* get_hybrid_property_columns

* get_logo

fget of ``logo`` return the path in the blok of the logo

        :rtype: absolute path or None if unexiste logo
        

* get_long_description

 fget of the ``long_description`` Column.Selection

        :rtype: the readme file of the blok
        

* get_modified_fields

return the fields which have changed and their previous values

* get_short_description

 fget of the ``short_description`` Column.Selection

        :rtype: the docstring of the blok
        

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* install

 Method to install the blok
        

* installed_version

* is_installed

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* list_by_state

 Return the blok name in function of the wanted states

        :param states: list of the state
        :rtype: list if state is a state, dict if the states is a list
        

* listen_update_installed_blok

* load

 Method to load the blok when the registry is completly loaded
        

* load_all

 Load all the installed bloks
        

* logo

* long_description

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* name

* order

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* short_description

* state

* uninstall

 Method to uninstall the blok
        

* uninstall_all

 Search and call the uninstall method for all the uninstalled bloks

        .. warning::

            Use the ``desc order`` to uninstall because we can't uninstall
            a dependancies before

        :param bloksname: list of the blok name to uninstall
        

* update_list

 Populate the bloks list and update the state of existing bloks
        

* update_sql_statement

* upgrade

 Method to update the blok
        

* version

Model.System.Cache
------------------

Properties:

* **table name** : system_cache

Fields
~~~~~~

* id

 **code** (system_cache.id),  **model** (Model.System.Cache),  **label** (Id),  **ftype** (Integer),  **entity_type** (Model.System.Column),  **autoincrement** (True),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* registry_name

 **code** (system_cache.registry_name),  **model** (Model.System.Cache),  **label** (Registry name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* method

 **code** (system_cache.method),  **model** (Model.System.Cache),  **label** (Method),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* clear_invalidate_cache

 Invalidate the cache that needs to be invalidated
        

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* detect_invalidation

 Return True if a new invalidation is found in the table

        :rtype: Boolean
        

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* getFieldType

* get_all_registry_names

* get_hybrid_property_columns

* get_invalidation

 Return the pointer of the method to invalidate
        

* get_last_id

 Return the last primary key ``id`` value
        

* get_modified_fields

return the fields which have changed and their previous values

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* id

* invalidate

 Call the invalidation for a specific method cached on a model

        :param registry_name: namespace of the model
        :param method: name of the method on the model
        :exception: CacheException
        

* invalidate_all

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* last_cache_id

int([x]) -> integer
int(x, base=10) -> integer

Convert a number or string to an integer, or return 0 if no arguments
are given.  If x is a number, return x.__int__().  For floating point
numbers, this truncates towards zero.

If x is not a number or if base is given, then x must be a string,
bytes, or bytearray instance representing an integer literal in the
given base.  The literal can be preceded by '+' or '-' and be surrounded
by whitespace.  The base defaults to 10.  Valid bases are 0 and 2-36.
Base 0 means to interpret the base from the string as an integer literal.
>>> int('0b100', base=0)
4

* lrus

dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* method

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* registry_name

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* update_sql_statement

Model.System.Parameter
----------------------

Applications parameters.

    This Model is provided by ``anyblok-core`` to give applications a uniform
    way of specifying in-database configuration.

    It is a simple key/value representation, where values can be of any type
    that can be encoded as JSON.

    A simple access API is provided with the :meth:`get`, :meth:`set`,
    :meth:`is_exist` and further methods.
    

Properties:

* **table name** : system_parameter

Fields
~~~~~~

* key

 **code** (system_parameter.key),  **model** (Model.System.Parameter),  **label** (Key),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* value

 **code** (system_parameter.value),  **model** (Model.System.Parameter),  **label** (Value),  **ftype** (Json),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* multi

 **code** (system_parameter.multi),  **model** (Model.System.Parameter),  **label** (Multi),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* get

 Return the value of the key

        :param key: key whose value to retrieve
        :param default: default value if key does not exists
        :return: associated value
        :rtype: anything JSON encodable
        :raises ParameterException: if the key doesn't exist and default is not
                                    set.
        

* getFieldType

* get_all_registry_names

* get_hybrid_property_columns

* get_modified_fields

return the fields which have changed and their previous values

* get_parameter

 Return the value of the key

        :param key: key whose value to retrieve
        :param default: default value if key does not exists
        :param remove: bool if True the entry will be removed
        :return: associated value
        :rtype: anything JSON encodable
        :raises ParameterException: if the key doesn't exist and default is not
                                    set.
        

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_exist

 Check if one parameter exist for the key

        :param key: key to check
        :rtype: bool
        

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* key

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* multi

* pop

Remove the given key and return the associated value.

        :param str key: the key to remove
        :return: the value before removal
        :param default: default value if key does not exists
        :rtype: any JSON encodable type
        :raises ParameterException: if the key wasn't present
        

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* set

 Insert or update parameter value for a key.

        .. note:: if the key already exists, the value will be updated

        :param str key: key to save
        :param value: value to save
        

* update_sql_statement

* value

Model.System.Sequence
---------------------

Database sequences.

    This Model allows applications to define and use Database sequences easily.

    It is a rewrapping of `SQLAlchemy sequences
    <http://docs.sqlalchemy.org/en/latest/core/defaults.html
    #sqlalchemy.schema.Sequence>`_, with additional formatting
    capabilities to use them, e.g, in fields of applicative Models.

    Sample usage::

        sequence = registry.System.Sequence.insert(
        code="string code",
        formater="One prefix {seq} One suffix")

    .. seealso:: The :attr:`formater` field.

    To get the next formatted value of the sequence::

        sequence.nextval()

    Full example in a Python shell::

        >>> seq = Sequence.insert(code='SO', formater="{code}-{seq:06d}")
        >>> seq.nextval()
        'SO-000001'
        >>> seq.nextval()
        'SO-000002'

    You can create a Sequence without gap warranty using `no_gap` while
    creating the sequence::


        >>> seq = Sequence.insert(
                code='SO', formater="{code}-{seq:06d}", no_gap=True)
        >>> commit()

        >>> # Transaction 1:
        >>> Sequence.nextvalBy(code='SO')
        'SO-000001'

        >>> # Concurrent transaction 2:
        >>> Sequence.nextvalBy(code='SO')
        ...
        sqlalchemy.exc.OperationalError: (psycopg2.errors.LockNotAvailable)
        ...
    

Properties:

* **table name** : system_sequence

Fields
~~~~~~

* id

 **code** (system_sequence.id),  **model** (Model.System.Sequence),  **label** (Id),  **ftype** (Integer),  **entity_type** (Model.System.Column),  **autoincrement** (True),  **foreign_key** (None),  **primary_key** (True),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* code

 **code** (system_sequence.code),  **model** (Model.System.Sequence),  **label** (Code),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* start

 **code** (system_sequence.start),  **model** (Model.System.Sequence),  **label** (Start),  **ftype** (Integer),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* current

 **code** (system_sequence.current),  **model** (Model.System.Sequence),  **label** (Current),  **ftype** (Integer),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (True),  **remote_model** (None)

* seq_name

 **code** (system_sequence.seq_name),  **model** (Model.System.Sequence),  **label** (Seq name),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* formater

 **code** (system_sequence.formater),  **model** (Model.System.Sequence),  **label** (Formater),  **ftype** (String),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

* no_gap

 **code** (system_sequence.no_gap),  **model** (Model.System.Sequence),  **label** (No gap),  **ftype** (Boolean),  **entity_type** (Model.System.Column),  **autoincrement** (False),  **foreign_key** (None),  **primary_key** (False),  **unique** (None),  **nullable** (False),  **remote_model** (None)

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _cls_seq_name

str(object='') -> str
str(bytes_or_buffer[, encoding[, errors]]) -> str

Create a new string object from the given object. If encoding or
errors is specified, then the object must expose a data buffer
that will be decoded using the given encoding and error handler.
Otherwise, returns the result of object.__str__() (if defined)
or repr(object).
encoding defaults to sys.getdefaultencoding().
errors defaults to 'strict'.

* _format_field

* _sa_class_manager

Tracks state information at the class level.

* _sa_registry

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* code

* create_sequence

Create the database sequence for an instance of Sequence Model.

        :return: suitable field values for insertion of the Model instance
        :rtype: dict
        

* current

* default_filter_on_sql_statement

* define_mapper_args

* define_table_args

* define_table_kwargs

* delete_sql_statement

Return a statement to delete some element

* execute_sql_statement

call SqlA execute method on the session

* expire

 Expire the attribute of the instance, theses attributes will be
        load at the next  call of the instance

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* expire_relationship_mapped

 Expire the objects linked with this object, in function of
        the mappers definition
        

* expunge

Expunge the instance in the session

* find_relationship

* find_remote_attribute_to_expire

* flag_modified

 Flag the attributes as modified

        see: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.expire
        

* formater

* getFieldType

* get_all_registry_names

* get_hybrid_property_columns

* get_modified_fields

return the fields which have changed and their previous values

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* id

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* metadata

A collection of :class:`_schema.Table`
    objects and their associated schema
    constructs.

    Holds a collection of :class:`_schema.Table` objects as well as
    an optional binding to an :class:`_engine.Engine` or
    :class:`_engine.Connection`.  If bound, the :class:`_schema.Table` objects
    in the collection and their columns may participate in implicit SQL
    execution.

    The :class:`_schema.Table` objects themselves are stored in the
    :attr:`_schema.MetaData.tables` dictionary.

    :class:`_schema.MetaData` is a thread-safe object for read operations.
    Construction of new tables within a single :class:`_schema.MetaData`
    object,
    either explicitly or via reflection, may not be completely thread-safe.

    .. seealso::

        :ref:`metadata_describing` - Introduction to database metadata

    

* nextval

Format and return the next value of the sequence.

        :rtype: str
        

* nextvalBy

Return next value of the first Sequence matching given criteria.

        :param crit: criteria to match, e.g., ``code=SO``
        :return: :meth:`next_val` result for the first matching Sequence,
                 or ``None`` if there's no match.
        

* no_gap

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* query_from_primary_keys

return a Query object in order to get object from primary keys.

        .. code::

            query = Model.query_from_primary_keys(**pks)
            obj = query.one()

        :param _*_*pks: dict {primary_key: value, ...}
        :rtype: Query object
        

* refresh

 Expire and reload all the attribute of the instance

        See: http://docs.sqlalchemy.org/en/latest/orm/session_api.html
        #sqlalchemy.orm.session.Session.refresh
        

* select_sql_statement

 Facility to do a SqlAlchemy query::

            stmt = MyModel.select()

        is equal at::

            from anyblok import select

            stmt = select(MyModel)

        but select can be overload by model and it is
        possible to apply whereclause or anything matter

        :param elements: pass at the SqlAlchemy query, if the element is a
                         string then thet are see as field of the model
        :rtype: SqlAlchemy Query
        

* seq_name

* start

* update_sql_statement

Model.Authorization
-------------------

Namespace for models supporting authorization policies.

Properties:

* **table name** : No table

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

Model.Documentation
-------------------

Properties:

* **table name** : No table

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _auto_doc

* _toRST

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* auto_doc

* auto_doc_blok

* auto_doc_model

* chapter2RST

* footer2RST

* header2RST

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* toRST

* toRST_blok

* toRST_model

* toSQL

* toUML

Model.Documentation.Blok
------------------------

Properties:

* **table name** : No table

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* exist

* filterBloks

* footer2RST

* getelements

* header2RST

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* toRST

* toRST_get_field

* toRST_write_params

Model.Documentation.Model
-------------------------

Properties:

* **table name** : No table

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* _auto_doc

* _toRST

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* exist

* filterModel

* footer2RST

* get_all_models

* getelements

* header2RST

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* toRST

* toRST_docstring

* toRST_field

* toRST_method

* toRST_properties

* toRST_properties_get

* toSQL_add_fields

* toSQL_add_table

* toUML_add_attributes

* toUML_add_model

Model.Documentation.Model.Field
-------------------------------

Properties:

* **table name** : No table

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* exist

* filterField

* footer2RST

* getelements

* header2RST

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* mappers

dict() -> new empty dictionary
dict(mapping) -> new dictionary initialized from a mapping object's
    (key, value) pairs
dict(iterable) -> new dictionary initialized as if via:
    d = {}
    for k, v in iterable:
        d[k] = v
dict(**kwargs) -> new dictionary initialized with the name=value pairs
    in the keyword argument list.  For example:  dict(one=1, two=2)

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* toRST

* toRST_docstring

* toRST_properties

* toRST_properties_get

* toSQL

* toSQL_column

* toSQL_field

* toSQL_relationship

* toUML

* toUML_column

* toUML_field

* toUML_relationship

Model.Documentation.Model.Attribute
-----------------------------------

Properties:

* **table name** : No table

Attributes, methods and class methods
~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~

* add_in_table_args

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* anyblok

 Define one registry

    A registry is linked to a database, and stores the definition of the
    installed Bloks, Models, Mixins for this database::

        registry = Registry('My database')
    

* exist

* filterAttribute

* footer2RST

* getelements

* header2RST

* hybrid_property_columns

Built-in mutable sequence.

If no argument is given, the constructor creates a new empty list.
The argument must be an iterable if specified.

* is_sql

bool(x) -> bool

Returns True when the argument x is true, False otherwise.
The builtins True and False are the only two instances of the class bool.
The class bool is a subclass of the class int, and cannot be subclassed.

* postcommit_hook

 Same in the registry a hook to call just after the commit

        you can choice if the hook is called in function of ``call_only_if``:

        * ``commited``: Call if the commit is done without exception
        * ``raised``: Call if one exception was raised
        * ``always``: Always call

        .. warning::

            Only one instance with same paramters of the hook is called
            after the commit

        :param method: the method to call on this model
        :param put_at_the_end_if_exist: If ``True`` the hook is move at the end
        :param call_only_if: ['commited' (default), 'raised', 'always']
        

* toRST

* toRST_docstring

* toUML

